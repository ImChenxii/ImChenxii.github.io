

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ChenXi">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++数组std::arrayarray的底层数据结构是固定数组，它的大小在定义后就不能被改变。不支持添加和删除元素或改变容器大小等操作，在定义一个array容器的时候必须指定类型和大小。连续空间存储，不能增删、扩张大小，可通过下标或迭代器遍历，速度很快。常用操作：  初始化：如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小，如果初始值数目小于array的大小，则它们">
<meta property="og:type" content="article">
<meta property="og:title" content="算法题解容器API">
<meta property="og:url" content="http://example.com/2018/04/01/D-DataStructureAndAlgorithm/Language-API/index.html">
<meta property="og:site_name" content="陈曦の博客">
<meta property="og:description" content="C++数组std::arrayarray的底层数据结构是固定数组，它的大小在定义后就不能被改变。不支持添加和删除元素或改变容器大小等操作，在定义一个array容器的时候必须指定类型和大小。连续空间存储，不能增删、扩张大小，可通过下标或迭代器遍历，速度很快。常用操作：  初始化：如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小，如果初始值数目小于array的大小，则它们">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-07T00:28:32.743Z">
<meta property="article:author" content="ChenXi">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>算法题解容器API - 陈曦の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>陈曦の博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法题解容器API"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-04-01 00:00" pubdate>
          2018年4月1日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          126 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法题解容器API</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><h4 id="数组std-array"><a href="#数组std-array" class="headerlink" title="数组std::array"></a>数组std::array</h4><p>array的底层数据结构是固定数组，它的大小在定义后就不能被改变。不支持添加和删除元素或改变容器大小等操作，在定义一个array容器的时候必须指定类型和大小。<br>连续空间存储，不能增删、扩张大小，可通过下标或迭代器遍历，速度很快。<br>常用操作：</p>
<ul>
<li>初始化：如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小，如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都是默认初始化值。</li>
<li>at(index)：访问指定index索引位置的元素，同时进行越界检查，越界会抛出越界异常。</li>
<li>operator[pos]：返回位于指定位置 pos 的元素的引用，不进行边界检查。</li>
<li>front(): 获取首个元素</li>
<li>back(): 获取末尾的元素</li>
<li>begin(): 获取指向第一个元素的迭代器</li>
<li>end(): 获取指向容器末元素后一元素的迭代器</li>
<li>empty(): 检查容器是否无元素，即是否 begin() &#x3D;&#x3D; end()</li>
<li>size(): 返回容器中的元素数，即 std::distance(begin(), end())</li>
<li>max_size(): 返回根据系统或库实现限制的容器可保有的元素最大数量，即对于最大容器的 std::distance(begin(), end())，因为每个 std::array&lt;T, N&gt; 都是固定大小容器，故 max_size 返回的值等于N</li>
<li>fill(value): 将数组中所有元素赋值value</li>
<li>swap(array): 将两个size相同的array元素交换，时间复杂度O(n)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span> 5&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-comment">// 获得index为4的值为5赋值给i</span><br><span class="hljs-type">int</span> i = numbers.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>);<br>numbers.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>) = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// operator[pos]同at()</span><br><span class="hljs-type">int</span> j = numbers[<span class="hljs-number">4</span>];<br>numbers[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 获取首尾元素</span><br>std::cout &lt;&lt; numbers.<span class="hljs-built_in">front</span>() &lt;&lt; numbers.<span class="hljs-built_in">back</span>() &lt;&lt; std::endl;<br><span class="hljs-comment">// 获取首尾迭代器</span><br>std::cout &lt;&lt; *numbers.<span class="hljs-built_in">begin</span>() &lt;&lt; *numbers.<span class="hljs-built_in">end</span>() &lt;&lt; std::endl; <span class="hljs-comment">// *numbers.end()返回0</span><br><span class="hljs-keyword">if</span> (!numbers.<span class="hljs-built_in">empty</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;not empty&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 赋值</span><br>numbers.<span class="hljs-built_in">fill</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 所有元素变为1000</span><br><span class="hljs-comment">// 交换</span><br>std::array&lt;<span class="hljs-type">int</span> 5&gt; num = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&#125;;<br>num.<span class="hljs-built_in">swap</span>(numbers); <span class="hljs-comment">// 两者元素交换</span><br>std::<span class="hljs-built_in">swap</span>(num, numbers); <span class="hljs-comment">// 等价上者</span><br><span class="hljs-comment">// array的遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    std::cout &lt;&lt; numbers[i] &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item : numbers) &#123;<br>    std::cout &lt;&lt; item &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 排序</span><br>std::<span class="hljs-built_in">sort</span>()包含三个参数：前两个是起始和结束地址，第三个是比较策略(可以自定义比较函数)<br>std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure>

<h4 id="动态数组std-vector"><a href="#动态数组std-vector" class="headerlink" title="动态数组std::vector"></a>动态数组std::vector</h4><p>vector的底层数据结构是动态数组，vector是动态空间，随着新元素的插入，旧存储空间不够用时，vector内部机制会自行扩充空间以容纳新元素。<br>两端添删元素快速，中间添删很慢，可用下标形式或者迭代器遍历，速度很快，随机访问: O(1)，在末尾插入或移除元素: O(1)，插入或移除元素: O()<br>常用操作：</p>
<ul>
<li>初始化: std::vector<int> v &#x3D; {7, 5, 16, 8};</li>
<li>at(pos): 访问pos索引位置元素，并进行越界检查</li>
<li>operator[pos]: 访问pos索引位置元素，时间复杂度O(1)</li>
<li>front(): 访问第一个元素</li>
<li>back(): 访问末尾的元素</li>
<li>data(): 返回指向内存中数组第一个元素的指针</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>max_size(): 返回可容纳的最大元素数</li>
<li>reserve(new_cap): 增加 vector 的容量到大于或等于 new_cap 的值。若 new_cap 大于当前的 capacity() ，则分配新存储，否则该方法不做任何事，reserve() 不更改 vector 的 size 。</li>
<li>capacity(): 返回当前存储空间能够容纳的元素数</li>
<li>clear(): 清空vector内的元素</li>
<li>insert(pos, value): 向指定pos迭代器位置插入元素，pos为迭代器的一个位置</li>
<li>erase(): 移除指定位置或者范围的元素</li>
<li>push_back(): 将元素添加到容器末尾</li>
<li>pop_back(): 移除末元素</li>
<li>resize(): 重设容器大小以容纳 count 个元素，若当前大小大于 count ，则减小容器为其首 count 个元素</li>
<li>swap(): 交换两个vector，不在单个元素上调用任何移动、复制或交换操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">16</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">// at(), operator[pos], front(), back(), begin(), end(), empty() 同array</span><br><span class="hljs-type">int</span> size = v.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回4</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">max_size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 返回4611686018427387903</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>(); <span class="hljs-comment">// 4</span><br>v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 4</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;; <span class="hljs-comment">// 10</span><br>v.<span class="hljs-built_in">clear</span>()<br>std::cout &lt;&lt; v.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br>std::cout &lt;&lt; v.<span class="hljs-built_in">empty</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// insert插入</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// &#123;7, 0, 5, 16, 8&#125; 在 pos 前插入 value</span><br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// &#123;7, 9, 9, 0, 5, 16, 8&#125; 在 pos 前插入 value 的 count 个副本</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">999</span>, <span class="hljs-number">3</span>&#125;;<br>v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">// &#123;7, 1, 999, 9, 9, 0, 5, 16, 8&#125;在 pos 前插入来自范围 [first, last) 的元素</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; num = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">501</span>, <span class="hljs-number">502</span>, <span class="hljs-number">503</span>&#125;;<br><span class="hljs-comment">// 在 pos 前插入来自 initializer_list ilist 的元素</span><br>numbers.<span class="hljs-built_in">insert</span>(numbers.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, arr, arr+<span class="hljs-number">2</span>); <span class="hljs-comment">// &#123;1, 999, 501, 502, 3&#125;，使用了数组的名称就是指向头元素指针特性</span><br>numbers.<span class="hljs-built_in">insert</span>(numbers.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>, num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">2</span>); <span class="hljs-comment">// &#123;1, 999, 0, -1, 3&#125; </span><br><span class="hljs-comment">// erase移除</span><br>num.<span class="hljs-built_in">erase</span>(num.<span class="hljs-built_in">begin</span>()); <span class="hljs-comment">// &#123;-1&#125; 移除位于 pos 的元素</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">16</span>, <span class="hljs-number">8</span>&#125;;<br>v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, v.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">// &#123;7, 8&#125; 移除范围 [first; last) 中的元素</span><br></code></pre></td></tr></table></figure>

<h4 id="栈std-stack"><a href="#栈std-stack" class="headerlink" title="栈std::stack"></a>栈std::stack</h4><p>是 FILO （先进后出）数据结构<br>常用操作：</p>
<ul>
<li>初始化：std::stack<int> stack &#x3D; {};</li>
<li>top(): 访问栈顶元素</li>
<li>empty(): 检查底层的容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>push(): 向栈顶插入元素</li>
<li>pop(): 删除栈顶元素</li>
<li>swap(): 交换两个栈的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::stack&lt;<span class="hljs-type">int</span>&gt; stack = &#123;&#125;;<br>stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>stack.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 1</span><br>stack.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<h4 id="队列std-queue"><a href="#队列std-queue" class="headerlink" title="队列std::queue"></a>队列std::queue</h4><p>是 FIFO （先进先出）数据结构<br>常用操作：</p>
<ul>
<li>初始化: std::queue<int> queue &#x3D; {};</li>
<li>front(): 访问第一个元素</li>
<li>back(): 访问最后一个元素</li>
<li>empty(): 检查底层的容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>push(): 向队列尾部插入元素</li>
<li>pop(): 删除队首元素</li>
<li>swap(): 交换两个队列的内容</li>
</ul>
<h4 id="双端队列deque"><a href="#双端队列deque" class="headerlink" title="双端队列deque"></a>双端队列deque</h4><p>deque则是一种双向开口的连续数据空间，双向开口是可以在头尾两端分别做元素的插入和删除操作。<br>两端添删元素快速，中间添删很慢，遍历速度快，复杂度：随机访问: O(1)，在结尾或起始插入或移除元素: O(1)，插入或移除元素: O(n)。<br>常用操作：</p>
<ul>
<li>初始化: std::deque<int> q &#x3D; {1, 2, 3, 4};</li>
<li>at(pos): 访问指定的元素，同时进行越界检查</li>
<li>operator[pos]: 访问指定的元素</li>
<li>front(): 访问第一个元素</li>
<li>back(): 访问最后一个元素</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>max_size(): 返回可容纳的最大元素数</li>
<li>shrink_to_fit(): 通过释放未使用的内存减少内存的使用</li>
<li>clear(): 清除内容</li>
<li>insert(): 插入元素</li>
<li>erase(): 擦除元素</li>
<li>push_back(): 将元素添加到容器末尾</li>
<li>pop_back(): 移除末元素</li>
<li>push_front(): 插入元素到容器起始</li>
<li>pop_front(): 移除首元素</li>
<li>resize(): 改变容器中可存储元素的个数</li>
<li>swap(): 两个双端队列交换<br>操作方式和功能和vector一致。</li>
</ul>
<h4 id="优先队列std-priority-queue"><a href="#优先队列std-priority-queue" class="headerlink" title="优先队列std::priority_queue"></a>优先队列std::priority_queue</h4><p>优先队列也是堆，底层实现是红黑树<br>常用操作：</p>
<ul>
<li>初始化最大堆: priority_queue<int> a; &#x2F; priority_queue&lt;int, vector<int>, less<int> &gt; a;</li>
<li>初始化最小堆: priority_queue&lt;int, vector<int>, greater<int> &gt; c;</li>
<li>top(): 访问堆顶元素</li>
<li>empty(): 检查底层的容器是否为空</li>
<li>size(): 返回元素个数</li>
<li>push(): 插入元素</li>
<li>pop(): 弹出堆顶元素</li>
</ul>
<h4 id="单向链表std-forward-list"><a href="#单向链表std-forward-list" class="headerlink" title="单向链表std::forward_list"></a>单向链表std::forward_list</h4><p>forward_list的底层数据结构为单向链表，forward_list容器支持前向遍历元素序列，允许常数时间内在任意位置的插入或删除操作并进行自动的内存管理。与list的主要区别是forward_list没有反方向的迭代器，不过也正因如此，forward_list的每个节点都节省了迭代器大小的开销，在元素众多的时候，将比list消耗少得多的内存，不支持快速随机访问，非连续空间存储，但只能在尾部添删元素。<br>forward_list是唯一一个不提供size()的容器。不提供的原因在于计算一个forward_list的长度需要线性的时间，库用户有时无法忍受这样的时间开销。其他容器提供的size()操作皆可以在常数时间内完成，也是唯一一个在给定位置之后插入新元素的容器。<br>常用操作：</p>
<ul>
<li>初始化: std::forward_list<int> q &#x3D; {1, 2, 3, 4};</li>
<li>front(): 返回到容器首元素的引用</li>
<li>before_begin(): 返回指向第一个元素之前迭代器</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>max_size(): 返回可容纳的最大元素数</li>
<li>clear(): 清除内容</li>
<li>insert_after(): 在某个元素后插入新元素</li>
<li>erase_after(): 擦除元素后的元素</li>
<li>push_front(): 插入元素到容器起始位置</li>
<li>pop_front(): 移除首元素</li>
<li>resize(): 改变容器中可存储元素的个数</li>
<li>swap(): 交换两个单向链表</li>
<li>merge(): 归并二个已排序链表为一个</li>
<li>remove(): 移除指定值的链表结点</li>
<li>remove_if(): 移除满足特定标准的元素</li>
<li>recerse(): 逆转容器中的元素顺序</li>
<li>unique(): 从容器移除所有相继的重复元素，只留下相等元素组中的第一个元素</li>
<li>sort(): 对元素进行排序</li>
<li>splice_after(): 从另一 forward_list 移动元素到指定位置，是左开右开区间移动</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;forward_list&gt;</span></span><br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; list = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>std::cout &lt;&lt; q.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">auto</span> beginIt = list.<span class="hljs-built_in">begin</span>();<br>list.<span class="hljs-built_in">insert_after</span>(beginIt, <span class="hljs-number">6</span>); <span class="hljs-comment">// &#123;1, 6, 2, 3, 4&#125; </span><br>list.<span class="hljs-built_in">insert_after</span>(beginIt, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// &#123;1, 5, 5, 6, 2, 3, 4&#125;</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>&#125;;<br>list.<span class="hljs-built_in">insert_after</span>(beginIt, v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>list.<span class="hljs-built_in">insert_atter</span>(beginIt, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br><br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; list1 = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;;<br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; list2 = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>list1.<span class="hljs-built_in">sort</span>();<br>list2.<span class="hljs-built_in">sort</span>();<br>list1.<span class="hljs-built_in">merge</span>(list2); <span class="hljs-comment">// list1: &#123;0 1 2 3 4 5 6 7 8 9&#125;</span><br><br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; l = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">12</span>&#125;;<br>list.<span class="hljs-built_in">remove</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// &#123;100, 2, 3, 10, 11, -1, 12&#125;</span><br>list.<span class="hljs-built_in">remove_if</span>([](<span class="hljs-type">int</span> n)&#123; <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">10</span>; &#125;);<br><br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; x = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>x.<span class="hljs-built_in">unique</span>(); <span class="hljs-comment">// &#123;1, 2, 3, 2, 1, 2&#125;</span><br><br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; l1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>std::forward_list&lt;<span class="hljs-type">int</span>&gt; l2 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>&#125;;<br>l2.<span class="hljs-built_in">splice_after</span>(l2.<span class="hljs-built_in">cbegin</span>(), l1, l1.<span class="hljs-built_in">cbegin</span>(), l1.<span class="hljs-built_in">cend</span>()); <span class="hljs-comment">// &#123;10, 2, 3, 4, 5, 11, 12&#125;</span><br><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">auto</span> it = list.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(it != list.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>    ++it;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="双向链表std-list"><a href="#双向链表std-list" class="headerlink" title="双向链表std::list"></a>双向链表std::list</h4><p>底层数据结构为双向循环链表，支持任意位置常数时间的插入&#x2F;删除操作，不支持快速随机访问。<br>非连续空间存储，增删访问元素都很快，但是浪费空间。<br>常用操作：</p>
<ul>
<li>初始化：std::list<int> nums1 &#x3D;  {3, 1, 4, 6, 5, 9};</li>
<li>front(): 访问第一个元素</li>
<li>back(): 访问最后一个元素</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>max_size(): 返回可容纳的最大元素数</li>
<li>clear(): 清除内容</li>
<li>insert(): 插入元素</li>
<li>erase(): 擦除元素</li>
<li>push_back(): 将元素添加到容器末尾</li>
<li>pop_back(): 移除末元素</li>
<li>push_front(): 插入元素到容器起始</li>
<li>pop_front(): 移除首元素</li>
<li>resize(): 改变容器中可存储元素的个数</li>
<li>swap(): 交换内容</li>
<li>merge(): 合并二个已排序链表</li>
<li>remove(): 移除指定值元素</li>
<li>remove_if(): 移除满足特定标准的元素</li>
<li>reverse(): 将该链表的所有元素的顺序反转</li>
<li>unique(): 删除连续的重复元素</li>
<li>sort(): 对元素进行排序</li>
<li>splice(): 从一个 list 转移元素给另一个，是左闭右开区间</li>
</ul>
<h4 id="排序非重复集合std-set"><a href="#排序非重复集合std-set" class="headerlink" title="排序非重复集合std::set"></a>排序非重复集合std::set</h4><p>底层数据结构一般是红黑树，是关联容器，含有 Key 类型对象的已排序集合。<br>搜索、移除和插入拥有对数复杂度。<br>常用操作：</p>
<ul>
<li>初始化：std::set<int> nums1 &#x3D; {3, 1, 4, 6, 5, 9};</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>max_size(): 返回容纳的元素数</li>
<li>clear(): 清除内容</li>
<li>insert(): 插入元素或结点</li>
<li>erase(): 擦除元素</li>
<li>swap(): 交换内容</li>
<li>count(): 返回匹配特定键的元素数量，因为容器不能有重复，所以只能是0&#x2F;1</li>
<li>find(): 指向键等于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器(end())</li>
<li>contains(): 检查容器中是否有关键等价于 key 的元素(C++20)</li>
<li>lower_bound(): 返回指向首个不小于 key 的元素的迭代器，若找不到这种元素，则返回尾后迭代器</li>
<li>upper_bound(): 返回指向首个大于给定键的元素的迭代器，若找不到这种元素，则返回尾后迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::set&lt;<span class="hljs-type">int</span>&gt; nums1 = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// &#123;1, 3, 4, 5, 6, 9&#125;</span><br>nums1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// &#123;1, 2, 3, 4, 5, 6, 9&#125;</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">auto</span> it = nums1.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != nums1.<span class="hljs-built_in">end</span>()) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>    ++it;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="排序可重复集合std-multiset"><a href="#排序可重复集合std-multiset" class="headerlink" title="排序可重复集合std::multiset"></a>排序可重复集合std::multiset</h4><p>是含有 Key 类型对象有序集的容器。不同于 set ，它允许多个关键拥有等价的值。用关键比较函数 Compare 进行排序。搜索、插入和移除操作拥有对数复杂度。<br>操作与set基本相同，count()返回的不再是0&#x2F;1。</p>
<h4 id="排序非重复键值对容器std-map"><a href="#排序非重复键值对容器std-map" class="headerlink" title="排序非重复键值对容器std::map"></a>排序非重复键值对容器std::map</h4><p>map 通常底层实现为红黑树，是有序键值对容器，它的元素的键是唯一的。用比较函数 Compare 排序键，搜索、移除和插入操作拥有对数复杂度。<br>常用操作：</p>
<ul>
<li>at(key): 访问指定的元素，同时进行越界检查，如果key不存在，报越界异常：std::out_of_range: map::at:  key not found</li>
<li>operator[key]: 访问或插入指定的元素，如果key不存在，返回类型默认值，可直接进行赋值，如果赋值key不存在，则是插入新的键值对</li>
<li>begin(): 返回指向容器第一个元素的迭代器</li>
<li>end(): 返回指向容器尾端的迭代器</li>
<li>empty(): 检查容器是否为空</li>
<li>size(): 返回容纳的元素数</li>
<li>max_size(): 返回可容纳的最大元素数</li>
<li>clear(): 清除内容</li>
<li>insert(): 插入元素</li>
<li>insert_or_assign(): 插入元素，或若关键已存在则赋值给当前元素</li>
<li>try_emplace(): 若键不存在则原位插入，若键存在则不做任何事</li>
<li>erase(): 擦除元素</li>
<li>swap(): 交换内容</li>
<li>count(): 为0&#x2F;1</li>
<li>find(): 指向键等于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</li>
<li>lower_bound(): 返回指向首个不小于给定键的元素的迭代器</li>
<li>upper_bound(): 返回指向首个大于给定键的元素的迭代器</li>
</ul>
<h4 id="排序可重复键值对容器std-multimap"><a href="#排序可重复键值对容器std-multimap" class="headerlink" title="排序可重复键值对容器std::multimap"></a>排序可重复键值对容器std::multimap</h4><p>multimap 是关联容器，含有关键-值 pair 的已排序列表，同时容许多个入口拥有同一关键。按照应用到关键的比较函数 Compare 排序。搜索、插入和移除操作拥有对数复杂度。<br>拥有等价关键的关键-值 pair 的顺序就是插入顺序，且不会更改。<br>常用操作同map，但是multimap不支持operator[]操作。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>同c++数组array，是存储固定大小的同类型元素的容器。<br>常用操作：</p>
<ul>
<li>初始化：dataType[] array; | dataType[] array; | dataType[] array &#x3D; new dataType[arraySize]; | dataType[] array &#x3D; {value0, value1, …, valuek};</li>
<li>operator[]: 访问指定索引位置的元素</li>
<li>array.length: 获得数组的长度</li>
<li>Arrays类:<ul>
<li>public static int binarySearch(Object[] a, Object key): 用二分查找算法在给定数组中搜索给定值的对象，数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回-1</li>
<li>public static boolean equals(long[] a, long[] a2): 如果两个数组以相同顺序包含相同的元素，则两个数组是相等的</li>
<li>public static void fill(int[] a, int val): 将指定的值分配给数组指定范围中的每个元素</li>
<li>public static void sort(Object[] a): 对指定对象数组根据其元素的自然顺序进行升序排列</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br>array[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>array[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 数组的遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>    System.out.println(array[i]); <span class="hljs-comment">// 1, 2, 0, 0, 0</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : array) &#123;<br>    System.out.println(array[i]);<br>&#125;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-comment">// 二分查找</span><br><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Arrays.binarySearch(array1, <span class="hljs-number">3</span>); <span class="hljs-comment">// index=1</span><br><br><span class="hljs-type">int</span>[] array2 = &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>&#125;;<br>Arrays.sort(array2); <span class="hljs-comment">// &#123;-1, 1, 5, 6, 8&#125; 直接改变原数组</span><br></code></pre></td></tr></table></figure>

<h4 id="动态数组ArrayList和Vector"><a href="#动态数组ArrayList和Vector" class="headerlink" title="动态数组ArrayList和Vector"></a>动态数组ArrayList和Vector</h4><p>ArrayList是最常用的List实现类，内部是通过数组实现的，允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。<br>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。<br>常用操作：</p>
<ul>
<li>初始化：ArrayList<Integer> list &#x3D; new ArrayList&lt;&gt;();</li>
<li>add(value): 添加元素到末尾</li>
<li>add(index, value): 添加元素到指定位置</li>
<li>clear(): 清空元素</li>
<li>clone(): 返回一个ArrayList的浅拷贝</li>
<li>contains(value): 如果包含value，返回true</li>
<li>get(index): 返回指定index的值</li>
<li>indexOf(value): 返回第一个value出现的索引，如果没有，返回-1</li>
<li>isEmpty(): 返回是否为空</li>
<li>lastIndexOf(value): 回最后一个value出现的索引，如果没有，返回-1</li>
<li>remove(index): 移除指定位置元素</li>
<li>remove(value): 移除第一个出现的元素，优先级低于index，只有当数组类型不是int时生效</li>
<li>removeAll(value): 移除全部为value的元素</li>
<li>removeIf(): 移除满足条件的元素</li>
<li>replaceAll(value): 对元素进行遍历替换</li>
<li>forEach(): 遍历全部元素</li>
<li>iterator(): 返回此数组的迭代器</li>
<li>set(index, value): 将指定位置设为value</li>
<li>size(): 返回ArrayList元素数量</li>
<li>sort(): 根据比较器来排序，必须实现内部Comparator接口</li>
<li>subList(index0, index1): 返回两个索引位置之间的子ArrayList </li>
<li>toArray(): 转换成数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br>ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">3</span>);<br>list.add(<span class="hljs-number">5</span>);<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.remove(<span class="hljs-number">1</span>); <span class="hljs-comment">// &#123;3, 1, 2&#125;</span><br>list.removeIf(item -&gt; (item %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)) <span class="hljs-comment">// 将满足后面lambda表达式的元素移除</span><br>ArrayList&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list1.add(<span class="hljs-string">&quot;ABC&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;BCD&quot;</span>;)<br>list1.replaceAll(e -&gt; e.toLowerCase()) <span class="hljs-comment">// 大写转小写</span><br>list.forEach(item -&gt; System.out.println(item));<br><span class="hljs-comment">// 迭代器</span><br>Iterator&lt;String&gt; iter = list1.iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    System.out.print(iter.next() + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br>Object[] a = list.toArray();<br>Integer[] b = (Integer[]) list.toArray();<br><br>Integer arr[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[list.size()];<br>arr = ArrLis.toArray(arr);<br><br><span class="hljs-comment">// 数组转ArrayList</span><br>Element[] array = &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(<span class="hljs-number">1</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(<span class="hljs-number">2</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(<span class="hljs-number">3</span>)&#125;;<br>ArrayList&lt;Element&gt; arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Element&gt;(Arrays.asList(array));<br></code></pre></td></tr></table></figure>
<p>ArrayList排序的几种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.Collections.sort()方法，只传入ArrayList时，按照字典序升序排序</span><br><span class="hljs-keyword">import</span> java.util.Collections;<br>Collections.sort(list);<br><br><span class="hljs-comment">// 2.Collections.sort()方法，传入ArrayList和自定义Comparator对象，按照指定方式排序</span><br><span class="hljs-type">Comparator</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-comment">// 降序</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-keyword">return</span> o1 &lt; o2 : <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>; <span class="hljs-comment">// jdk7之后必须是相反数</span><br>    &#125;<br>&#125;<br>Collections.sort(list, c);<br><span class="hljs-comment">// 使用lambda表示式简化</span><br>Collections.sort(list, (Integer o1, Integer o2) -&gt; o2 - o1);<br><br><span class="hljs-comment">// 3.ArrayList的sort函数</span><br>list.sort(c); <span class="hljs-comment">// 同样可简化</span><br></code></pre></td></tr></table></figure>

<h4 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h4><p>先进后出的数据结构<br>常用操作：</p>
<ul>
<li>初始化: Stack<Integer> stack &#x3D; new Stack&lt;&gt;();</li>
<li>empty(): 检查是否为空</li>
<li>peek(): 查看栈顶元素</li>
<li>pop(): 弹出栈顶元素</li>
<li>push(value): 将元素入栈</li>
<li>search(value): 找到距离栈顶最近的元素距离栈顶的距离</li>
</ul>
<h4 id="队列Queue"><a href="#队列Queue" class="headerlink" title="队列Queue"></a>队列Queue</h4><p>先进先出的数据结构<br>常用操作：</p>
<ul>
<li>初始化: Queue<Integer> queue &#x3D; new LinkedList&lt;&gt;();</li>
<li>add(value): 添加元素到队尾</li>
<li>add(index, value): 添加元素到指定位置</li>
<li>addFirst(value): 添加元素到对首</li>
<li>contains(value): 是否包含value</li>
<li>clear(): 清空容器</li>
<li>get(index): 获取指定位置元素</li>
<li>getFirst(): 获取队首元素</li>
<li>getLast(): 获取队尾元素</li>
<li>indexOf(value): value首个位置索引，没有返回-1</li>
<li>offer(value): 插入元素到队尾</li>
<li>peek(): 查看队首元素</li>
<li>peekLast(): 查看队尾元素</li>
<li>pool(): 移除队首元素</li>
<li>poolFirst(): 移除队首元素</li>
<li>poolLast(): 移除队尾元素</li>
<li>remove(): 移除队首元素</li>
<li>remove(index): 移除指定位置元素</li>
<li>remove(value): 移除第一个出现的value元素</li>
<li>set(index, value): 将index位置设置为value</li>
<li>size(): 返回队列元素个数</li>
<li>toArray(): 同ArrayList</li>
</ul>
<h4 id="双端队列ArrayDeque"><a href="#双端队列ArrayDeque" class="headerlink" title="双端队列ArrayDeque"></a>双端队列ArrayDeque</h4><p>可从队首队尾插入弹出元素的队列结构<br>常用操作：</p>
<ul>
<li>初始化: ArrayDeque<Integer> queue &#x3D; new ArrayDeque&lt;&gt;();</li>
<li>offer(): 元素入队尾</li>
<li>push(): 元素入队首</li>
<li>peek(): 查看队首元素</li>
<li>peekLast(): 查看队尾元素</li>
<li>poll(): 移除队首元素</li>
<li>pollLast(): 移除队尾元素</li>
<li>clear(): 清空队列元素</li>
<li>contains(): 返回队列中是否包含元素</li>
<li>size(): 返回元素个数</li>
<li>isEmpty(): 检查是否为空</li>
<li>iterator(): 返回此队列的迭代器</li>
<li>toArray()</li>
</ul>
<h4 id="优先队列-x2F-堆PriorityQueue"><a href="#优先队列-x2F-堆PriorityQueue" class="headerlink" title="优先队列&#x2F;堆PriorityQueue"></a>优先队列&#x2F;堆PriorityQueue</h4><p>根据指定排序规则的最大&#x2F;小堆<br>常用操作：</p>
<ul>
<li>初始化: PriorityQueue<Integer> heap &#x3D; new PriorityQueue&lt;&gt;(); PriorityQueue<ListNode> queue&#x3D; new PriorityQueue<ListNode>(lists.length, (o1, o2) -&gt; (o1.val - o2.val)); &#x2F;&#x2F; 默认最小堆</li>
<li>offer(): 元素入堆</li>
<li>peek(): 查看堆顶元素</li>
<li>poll(): 移除堆顶元素</li>
<li>size(): 堆内元素个数</li>
<li>contains(): 返回堆内是否包含某个元素</li>
<li>iterator(): 返回迭代器</li>
</ul>
<h4 id="无序键值对集合HashMap"><a href="#无序键值对集合HashMap" class="headerlink" title="无序键值对集合HashMap"></a>无序键值对集合HashMap</h4><p>使用哈希映射的散列表<br>常用操作:</p>
<ul>
<li>初始化: HashMap&lt;Integer, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</li>
<li>put(key, value): 添加键值对</li>
<li>get(key): 获取指定key对应值</li>
<li>getOrDefault(key, defaultValue): 如果有此键值对，返回对应值，没有，返回默认值</li>
<li>remove(key): 删除指定键值对，可加参数value，仅当指定key的value对应上参数时才会删除</li>
<li>containsKey(key): 返回是否包含此key</li>
<li>containsValue(value): 返回是否包含此value</li>
<li>isEmpty(): 返回是否为空</li>
<li>size(): 返回元素个数</li>
<li>replace(key, value): 将指定key对应的value进行替换</li>
<li>replace(key, old, new): 仅当对应key的value为old时才将其value替换为new</li>
</ul>
<h4 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h4><p>StringBuffer和StringBuilder都是字节流，其中StringBuilder是线程不安全的，但是速度快，StringBuffer是线程安全的，速度相对较慢。<br>常用操作:</p>
<ul>
<li>初始化: StringBuffer res &#x3D; new StringBuffer(str); StringBuffer res &#x3D; new StringBuffer(); StringBuffer res &#x3D; new StringBuffer(10); &#x2F;&#x2F; 提前开拓容量</li>
<li>append(str&#x2F;char&#x2F;sb&#x2F;int…): 增添元素到末尾</li>
<li>capacity(): 返回当前容量</li>
<li>charAt(index): 返回指定索引的字符</li>
<li>delete(start, end): 删除指定索引序列位置字符</li>
<li>deleteCharAt(index): 删除指定位置字符</li>
<li>indexOf(str): 返回第一次出现的索引</li>
<li>length(): 返回当前元素个数</li>
<li>insert(index, value): 将字符插入到指定位置</li>
<li>replace(start, end, str): 指定位置替换字符串</li>
<li>setCharAt(index, char): 修改指定位置字符</li>
<li>setLength(): 设定字符序列长度</li>
<li>subString(start, end): 子字符串</li>
<li>toString(): 转为String</li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>Python中没有明确的栈、动态数组的定义，都可以使用列表来表示。<br>常用操作:</p>
<ul>
<li>初始化: a &#x3D; [1, 2, 3]  a &#x3D; list() a &#x3D; list(tuple) 将元组转化成列表</li>
<li>append(): 增加元素到末尾，相当于队列入队</li>
<li>insert(index, value): 在指定位置插入元素</li>
<li>remove(value): 移除第一个值为value的元素</li>
<li>index(value): 返回第一个为value的索引</li>
<li>pop(): 移除指定索引位置元素，pop(0): 相当于出队，但效率很慢 pop(): 移除最后一个元素，相当于出栈</li>
<li>clear(): 清空元素</li>
<li>count(value): 统计value出现的次数</li>
<li>sort(reverse&#x3D;False): 排序</li>
<li>reverse(): 反转列表</li>
<li>copy(): 浅拷贝</li>
<li>len(list): 返回列表元素个数</li>
<li>max&#x2F;min(list): 返回列表最大&#x2F;小值</li>
<li>sorted(list): sort是在列表上原地操作，sorted是对所有可迭代对象排序后返回一个拷贝对象</li>
<li>“,”.join(list): 使用指定的分隔符拼接列表</li>
<li>map(fun, list): map映射</li>
</ul>
<h4 id="双端队列deque-1"><a href="#双端队列deque-1" class="headerlink" title="双端队列deque"></a>双端队列deque</h4><p>列表也可以用作队列，其中先添加的元素被最先取出，然而列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)。<br>在collections.deque中</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">#数据结构</a>
      
        <a href="/tags/Python/">#Python</a>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法题解容器API</div>
      <div>http://example.com/2018/04/01/D-DataStructureAndAlgorithm/Language-API/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ChenXi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年4月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/09/01/D-DataStructureAndAlgorithm/Algorithm-summary/" title="算法题思路总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">算法题思路总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/01/04/D-DataStructureAndAlgorithm/C-JianzhiOffer/28-MoreThanHalfNum_Solution/" title="剑指Offer题解系列（二十八）：数组中出现次数超过一半的数字">
                        <span class="hidden-mobile">剑指Offer题解系列（二十八）：数组中出现次数超过一半的数字</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
